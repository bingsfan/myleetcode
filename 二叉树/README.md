# 二叉树刷题总结

## 二叉树的遍历

* 递归遍历
* 统一迭代遍历
* 层序遍历
* 二叉搜索树的遍历

## 求二叉树的属性

* 是否对称？
  * 递归：后序，比较根节点的左右子树是不是相互翻转的
  * `迭代没有尝试过！！！！`
* 求最大深度
  * 递归：后序，没啥问题，求根节点的最大高度，其实求每个节点的当前高度都是这个代码
  * 迭代：用层序遍历，res返回最后一次循环队列的结果就行了
* 求最小深度
  * 递归：后序，这个跟最大深度不一样的点在于，要区分是否左右子树为空，不能直接返回1+min(left,right)
  * 迭代：层序遍历，如果遇到叶子结点了就直接返回，这就是最小的深度
  * `二刷错过`
* 求有多少个节点
  * 递归：后序遍历，左右子树遍历完了然后再1+left+right
  * 迭代：直接层序，res++就行了
  * `我踏马也有点问题草`
* 是否是平衡二叉树
  * 递归：后序，求出来高度差，如果不符合就false，有两种写法，第二种优化过了
  * 迭代效率很低就别用了
  * `这道题不太熟练`
* 找所有路径
  * 递归：根节点放在path里面就是前序，我踏马打印和访问都还有点问题，不过直接前序就行了，有点蠢只能说，跟回溯里面的求路径很像。如果根节点要放在递归函数里面那就是中序，我喜欢放在外面
  * 迭代没用过，统一中序迭代应该没啥问题把，到时候再试试
* 求左叶子之和
  * 递归：后序，我做的有点问题，现在还不一定想明白呢
  * 迭代：我踏马直接层序，判断条件就是cur->left&&!cur->left->left&&!cur->right->right,保证cur的左节点是叶子结点，然后res加上这个值就行了
* 求路径总和
  * 递归：前序，和找所有路径那道题有点像，不过多一个参数，然后返回值是bool，这种有返回值的回溯我踏马现在有点没完全吃透呢，超！！
  * 迭代就别jb看了，这种路径的题统一用递归把

## 二叉树的修改与构建（包含BST）
**这一块的题好像都是勾八前序，还真是BST也是**
* 翻转二叉树
  * 递归：前序，莫名其妙就做出来了，swap左右孩子完了，左右子树再一递归就完事儿
  * 这种修改的不想用迭代了
* 构造二叉树
  * 前序，找分割点，其实就是把根节点构建出来，然后分别构建左右子树
* 构造最大的二叉树
  * 前序，和上面那个题基本一致
* 合并两个二叉树
  * 前序，如果两个当前节点都不为空，直接加一块，如果有一个为空那就要的是不为空的那一个，然后递归左右子树

**下面我把二叉搜索树的也加上来**
* BST的插入
  * 要用一个parent记录要在树上的哪个叶子结点上插入，带不带返回值的递归都可以，`试试带返回值的把，感觉对这块理解还不是很透彻`
  * 迭代法我也写了，感觉BST这块有的题用迭代法还简单点
* BST的删除
  * 经典题目，我是用迭代写的，迭代改变它树的结构还有两种方法可以选，第二种麻烦点但是树的形状变化不大
  * `递归还没整呢，感觉carl写的一坨，之后再看看`
* 修剪BST
  * 前序，这题就只能用递归了，要不然就加上删除的方法迭代去做。前序遍历，这也有返回值，如果当前的节点大于val了，说明当前节点和右子树都废了，直接return trim(node->left)，同样，小于也是类似的操作，如果再范围内就递归访问左右子树
* 构造平衡二叉树
  * 前序，和构造那块的题有点像，不过要取数组的中间节点，构造二叉树+二分查找把
  
## 求BST的属性
* BST的搜索
  * 递归：应该算是后序把，有返回值的，注意一下中止条件
  * 迭代：那可太简单了，喜欢捏
* 是不是BST
  * 递归：转换成一个数组再去判断去
  * 迭代：没做，感觉没啥意义，数组够用了
* 求BST的最小绝对值差
  * 转成数组一算就行了
* 求BST的众数
  * 方法1，直接遍历完整个树，用一个map或者优先级队列一装进去就完事儿`代码里面没这个奥`，这个方法适合任何树都可以用
  * 方法2只适用于BST，不想弄，没啥意义
* 将BST转换成累加树
  * 递归：感觉还好，右中左遍历，这个遍历顺序就很好想
  * 迭代：`没写，好好试试，想想为什么是中序`

## 二叉树的公共祖先问题
* 二叉树的公共祖先
  * 递归：后序，要判断左右子树是不是有值
* BST的公共祖先
  * 递归：`没写`
  * 迭代：这个方法感觉更简单点